// -----------------------------------------------------------------------
// <copyright file="Generator.cs" company="Andrii Kurdiumov">
// Copyright (c) Andrii Kurdiumov. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace StoreKeeper;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// Generator for IOC storage.
/// </summary>
[Generator]
public partial class Generator : ISourceGenerator
{
    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        // context.RegisterForPostInitialization((pi) => pi.AddSource("SqlMarshalAttribute.cs", AttributeSource));
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        var hasNullableAnnotations = context.Compilation.Options.NullableContextOptions != NullableContextOptions.Disable;

        const string AutoGeneratedHeader = @"// <auto-generated>
// Code generated by Store Keeper Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#pragma warning disable 1591
";

        var sourceCode = new IndentedStringBuilder(AutoGeneratedHeader);
        sourceCode.AppendLine("using System;");
        sourceCode.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceCode.AppendLine();
        sourceCode.AppendLine(@"internal class CustomServiceProvider : IServiceProvider, IServiceScopeFactory
{
    public IServiceScope CreateScope()
    {
        return new ScopedServices();
    }

    private ScopedServices implicitScope = new ScopedServices();
");

        var descriptors = ConvertToDescriptors(receiver.Methods);
        sourceCode.PushIndent();
        this.GenerateScopedClass(sourceCode, descriptors);
        sourceCode.PopIndent();
        sourceCode.AppendLine();
        sourceCode.AppendLine(@"    public object GetService(Type t)
    {
        if (t == typeof(Microsoft.Extensions.DependencyInjection.IServiceScope))
        {
            return this;
        }

        return implicitScope.GetService(t);
    }
}

public static class StoreKeeperExtensions
{
    public static IServiceProvider BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.DependencyInjection.ServiceProviderOptions options)
    {
        return new CustomServiceProvider();
    }
    public static IServiceProvider BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        return new CustomServiceProvider();
    }
}");
        foreach (var descriptor in descriptors)
        {
            sourceCode.AppendLine($"// {descriptor.Scope} {descriptor.InterfaceType} {descriptor.ImplementationType}");
        }

        context.AddSource($"ioc_constructor.cs", SourceText.From(sourceCode.ToString(), Encoding.UTF8));
    }

    internal static IList<ServiceDescriptor> ConvertToDescriptors(List<MemberAccessExpressionSyntax> serviceRegistrationCandidates)
    {
        List<ServiceDescriptor> result = new();
        foreach (var i in serviceRegistrationCandidates)
        {
            var name = i.Name;
            if (name is GenericNameSyntax genericNameSyntax)
            {
                var identifier = genericNameSyntax.Identifier;
                var typesList = genericNameSyntax.TypeArgumentList.Arguments;
                var interfaceType = typesList[0];
                var implementationType = typesList.ElementAtOrDefault(1) ?? interfaceType;
                if (Enum.TryParse<ServiceScope>(genericNameSyntax.Identifier.ToString().Substring(3), out var scope))
                {
                    result.Add(new ServiceDescriptor(scope, interfaceType, implementationType));
                }
            }
        }

        return result;
    }

    internal void GenerateScopedClass(IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors)
    {
        builder.AppendLine("internal class ScopedServices : IServiceProvider, IServiceScope");
        builder.AppendLine("{");
        builder.PushIndent();
        builder.AppendLine("public IServiceProvider ServiceProvider => this;");
        builder.AppendLine();
        builder.AppendLine("public void Dispose() {}");
        builder.AppendLine();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"private {descriptor.ImplementationType} {this.GetServiceBackingField(descriptor)};");
            builder.AppendLine();
        }

        builder.AppendLine("public object GetService(Type t)");
        builder.AppendLine("{");
        builder.PushIndent();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"if (t == typeof({descriptor.InterfaceType}))");
            builder.AppendLine("{");
            builder.PushIndent();
            var backingField = this.GetServiceBackingField(descriptor);
            builder.AppendLine($"{backingField} = {backingField} ?? {this.GetInstantiationExpression(descriptor, descriptors)};");
            builder.AppendLine($"return {backingField};");
            builder.PopIndent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.AppendLine(@"return null;");
        builder.PopIndent();

        builder.AppendLine("}");
        builder.PopIndent();
        builder.AppendLine("}");
    }

    internal string GetInstantiationExpression(ServiceDescriptor descriptor, IList<ServiceDescriptor> descriptors)
    {
        return $"new {descriptor.ImplementationType}()";
    }

    internal string GetServiceBackingField(ServiceDescriptor descriptor)
    {
        return $"_{descriptor.ImplementationType}";
    }

    internal class ServiceDescriptor
    {
        public ServiceDescriptor(ServiceScope scope, TypeSyntax interfaceType, TypeSyntax implementationType)
        {
            this.Scope = scope;
            this.InterfaceType = interfaceType;
            this.ImplementationType = implementationType;
        }

        public ServiceScope Scope { get; }

        public TypeSyntax InterfaceType { get; }

        public TypeSyntax ImplementationType { get; }
    }

    internal class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<MemberAccessExpressionSyntax> Methods { get; } = new List<MemberAccessExpressionSyntax>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is MemberAccessExpressionSyntax invocationExpressionSyntax)
            {
                var x = invocationExpressionSyntax.Name.ToString();
                if (x.StartsWith("AddScoped") || x.StartsWith("AddSingleton") || x.StartsWith("AddTransient"))
                {
                    // Get the symbol being declared by the field, and keep it if its annotated
                    this.Methods.Add(invocationExpressionSyntax);
                }
            }
        }
    }
}
