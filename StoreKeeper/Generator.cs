// -----------------------------------------------------------------------
// <copyright file="Generator.cs" company="Andrii Kurdiumov">
// Copyright (c) Andrii Kurdiumov. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace StoreKeeper;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// Generator for IOC storage.
/// </summary>
[Generator]
public partial class Generator : ISourceGenerator
{
    /// <summary>
    /// Gets or sets a value indicating whether generate file headers.
    /// </summary>
    public bool GenerateHeaders { get; set; } = true;

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        // context.RegisterForPostInitialization((pi) => pi.AddSource("SqlMarshalAttribute.cs", AttributeSource));
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        var hasNullableAnnotations = context.Compilation.Options.NullableContextOptions != NullableContextOptions.Disable;

        const string AutoGeneratedHeader = @"// <auto-generated>
// Code generated by Store Keeper Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#pragma warning disable 1591
";

        var builder = new IndentedStringBuilder(this.GenerateHeaders ? AutoGeneratedHeader : string.Empty);
        builder.AppendLine("using System;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine();
        builder.AppendLine(@"public sealed class ServiceProviderAot : IServiceProvider, System.IDisposable");
        builder.OpenBraces();
        builder.AppendLine("internal ServiceProviderAot(Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        builder.OpenBraces();
        builder.AppendLine(@"this.serviceScopeFactory = new ServiceScopeFactory(services);");
        builder.AppendLine(@"this.implicitScope = serviceScopeFactory.CreateScope();");
        builder.CloseBraces();
        builder.AppendLine();

        var descriptors = receiver.DetectedServices;
        this.GenerateServiceScopeFactoryClass(builder, descriptors);
        builder.AppendLine("private ServiceScopeFactory serviceScopeFactory;");
        builder.AppendLine();
        builder.AppendLine(@"private Microsoft.Extensions.DependencyInjection.IServiceScope implicitScope;");
        builder.AppendLine();

        builder.AppendLine(@"public void Dispose()");
        builder.OpenBraces();
        builder.AppendLine(@"implicitScope.Dispose();");
        builder.CloseBraces();
        builder.AppendLine();

        this.GenerateScopedClass(builder, descriptors);
        builder.AppendLine();
        builder.AppendLine(@"public object GetService(Type t)
    {
        if (t == typeof(Microsoft.Extensions.DependencyInjection.IServiceScopeFactory))
        {
            return serviceScopeFactory;
        }

        return implicitScope.ServiceProvider.GetService(t);
    }
}

public static class StoreKeeperExtensions
{
    public static ServiceProviderAot BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.DependencyInjection.ServiceProviderOptions options)
    {
        return new ServiceProviderAot(services);
    }
    public static ServiceProviderAot BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        return new ServiceProviderAot(services);
    }
}");
        context.AddSource($"ioc_constructor.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private void GenerateServiceScopeFactoryClass(IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors)
    {
        builder.AppendLine("private sealed class ServiceScopeFactory : IServiceScopeFactory");
        builder.OpenBraces();
        builder.AppendLine("private Microsoft.Extensions.DependencyInjection.IServiceCollection services;");
        builder.AppendLine();
        builder.AppendLine("public ServiceScopeFactory(Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        builder.OpenBraces();
        builder.AppendLine("this.services = services;");
        builder.CloseBraces();
        builder.AppendLine();
        builder.AppendLine("public IServiceScope CreateScope()");
        builder.OpenBraces();
        builder.AppendLine("var result = new ScopedServices();");
        if (descriptors.Any(_ => _.UseInstance || _.UseFactory))
        {
            builder.AppendLine("foreach (var serviceDescriptor in this.services)");
            builder.OpenBraces();
            foreach (var descriptor in descriptors)
            {
                if (!descriptor.UseInstance && !descriptor.UseFactory)
                {
                    continue;
                }

                var type = descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var backingField = this.GetServiceBackingField(descriptor);
                builder.AppendLine($"if (serviceDescriptor.ServiceType == typeof({type}))");
                builder.OpenBraces();
                if (descriptor.UseInstance)
                {
                    builder.AppendLine($"result.{backingField} = ({type})serviceDescriptor.ImplementationInstance;");
                }

                if (descriptor.UseFactory)
                {
                    builder.AppendLine($"result.{backingField}Factory = (Func<IServiceProvider, Object>)serviceDescriptor.ImplementationFactory;");
                }

                builder.CloseBraces();
            }

            builder.CloseBraces();
            builder.AppendLine();
        }

        builder.AppendLine("return result;");
        builder.CloseBraces();
        builder.CloseBraces();
        builder.AppendLine();
    }

    private void GenerateScopedClass(IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors)
    {
        builder.AppendLine("internal class ScopedServices : IServiceProvider, Microsoft.Extensions.DependencyInjection.IServiceScope");
        builder.AppendLine("{");
        builder.PushIndent();
        builder.AppendLine("public IServiceProvider ServiceProvider => this;");
        builder.AppendLine();
        builder.AppendLine("public void Dispose()");
        builder.AppendLine("{");
        builder.PushIndent();
        foreach (var descriptor in descriptors.Where(_ => _.IsDisposable))
        {
            var backingField = this.GetServiceBackingField(descriptor);
            builder.AppendLine($"if ({backingField} != null)");
            builder.AppendLine("{");
            builder.PushIndent();
            builder.AppendLine($"((System.IDisposable){backingField}).Dispose();");
            builder.AppendLine($"{backingField} = null;");
            builder.PopIndent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.PopIndent();
        builder.AppendLine("}");
        builder.AppendLine();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"internal {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {this.GetServiceBackingField(descriptor)};");
            builder.AppendLine();
            if (descriptor.UseFactory)
            {
                builder.AppendLine($"internal Func<IServiceProvider, Object> {this.GetServiceBackingField(descriptor)}Factory;");
                builder.AppendLine();
            }
        }

        builder.AppendLine("public object GetService(Type t)");
        builder.AppendLine("{");
        builder.PushIndent();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"if (t == typeof({descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}))");
            builder.AppendLine("{");
            builder.PushIndent();
            var backingField = this.GetServiceBackingField(descriptor);
            if (descriptor.UseFactory)
            {
                builder.AppendLine($"{backingField} = {backingField} ?? ({descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}){backingField}Factory(this);");
            }
            else if (!descriptor.UseInstance)
            {
                builder.AppendLine($"{backingField} = {backingField} ?? {this.GetInstantiationExpression(descriptor, descriptors)};");
            }

            builder.AppendLine($"return {backingField};");
            builder.PopIndent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.AppendLine(@"return null;");
        builder.PopIndent();

        builder.AppendLine("}");
        builder.PopIndent();
        builder.AppendLine("}");
    }

    private string GetInstantiationExpression(ServiceDescriptor descriptor, IList<ServiceDescriptor> descriptors)
    {
        return $"new {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}()";
    }

    private string GetServiceBackingField(ServiceDescriptor descriptor)
    {
        return $"_{descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace('.', '_')}";
    }

    internal class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<ServiceDescriptor> DetectedServices { get; } = new();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is InvocationExpressionSyntax invocationExpressionSyntax)
            {
                if (invocationExpressionSyntax.Expression is not MemberAccessExpressionSyntax memberAccessException)
                {
                    return;
                }

                var name = memberAccessException.Name;
                var x = name.ToString();
                if (x.StartsWith("AddScoped") || x.StartsWith("AddSingleton") || x.StartsWith("AddTransient"))
                {
                    if (name is GenericNameSyntax genericNameSyntax)
                    {
                        this.ProcessGenericSyntax(context, genericNameSyntax);
                    }
                    else if (name is IdentifierNameSyntax identifierNameSyntax)
                    {
                        var argument = invocationExpressionSyntax.ArgumentList.Arguments[0];
                        TypeInfo interfaceTypeInfo = GetExpressionType(context, argument);
                        if (interfaceTypeInfo.Type is not null)
                        {
                            var useInstance = argument.Expression is ObjectCreationExpressionSyntax;
                            var scope = (ServiceScope)Enum.Parse(typeof(ServiceScope), x.Substring(3));
                            var descriptor = new ServiceDescriptor(
                                scope,
                                interfaceTypeInfo.Type,
                                interfaceTypeInfo.Type)
                            {
                                UseInstance = useInstance,
                                UseFactory = !useInstance,
                            };
                            this.DetectedServices.Add(descriptor);
                        }
                    }
                }
            }
        }

        private static TypeInfo GetExpressionType(GeneratorSyntaxContext context, ArgumentSyntax argument)
        {
            var expression = argument.Expression switch
            {
                ParenthesizedLambdaExpressionSyntax pes => pes.ExpressionBody ?? throw new NotSupportedException("Complex lambda expression does not supported"),
                _ => argument.Expression,
            };
            return context.SemanticModel.GetTypeInfo(expression);
        }

        private void ProcessGenericSyntax(GeneratorSyntaxContext context, GenericNameSyntax genericNameSyntax)
        {
            var identifier = genericNameSyntax.Identifier;
            if (!Enum.TryParse<ServiceScope>(identifier.ToString().Substring(3), out var scope))
            {
                return;
            }

            var typesList = genericNameSyntax.TypeArgumentList.Arguments;
            var interfaceType = typesList[0];
            var implementationType = typesList.ElementAtOrDefault(1) ?? interfaceType;
            TypeInfo interfaceTypeInfo = context.SemanticModel.GetTypeInfo(interfaceType);
            TypeInfo implementationTypeInfo = context.SemanticModel.GetTypeInfo(implementationType);
            if (interfaceTypeInfo.Type is not null && implementationTypeInfo.Type is not null)
            {
                ServiceDescriptor descriptor = new ServiceDescriptor(
                    scope,
                    interfaceTypeInfo.Type,
                    implementationTypeInfo.Type);
                this.DetectedServices.Add(descriptor);
            }
        }
    }
}
