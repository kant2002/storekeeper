// -----------------------------------------------------------------------
// <copyright file="Generator.cs" company="Andrii Kurdiumov">
// Copyright (c) Andrii Kurdiumov. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace StoreKeeper;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// Generator for IOC storage.
/// </summary>
[Generator]
public partial class Generator : ISourceGenerator
{
    /// <summary>
    /// Gets or sets a value indicating whether generate file headers.
    /// </summary>
    public bool GenerateHeaders { get; set; } = true;

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        // context.RegisterForPostInitialization((pi) => pi.AddSource("SqlMarshalAttribute.cs", AttributeSource));
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        var hasNullableAnnotations = context.Compilation.Options.NullableContextOptions != NullableContextOptions.Disable;

        const string AutoGeneratedHeader = @"// <auto-generated>
// Code generated by Store Keeper Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#pragma warning disable 1591
";

        var builder = new IndentedStringBuilder(this.GenerateHeaders ? AutoGeneratedHeader : string.Empty);
        builder.AppendLine("using System;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine();

        var descriptors = receiver.DetectedServices;
        if (descriptors.Count == 0)
        {
            return;
        }

        var scopedServices = descriptors.Where(_ => _.Scope == ServiceScope.Scoped).ToList();
        var singletonServices = descriptors.Where(_ => _.Scope == ServiceScope.Singleton).ToList();

        builder.AppendLine(@"public sealed class ServiceProviderAot : IServiceProvider, System.IDisposable");
        builder.OpenBraces();
        builder.AppendLine("internal ServiceProviderAot(Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        builder.OpenBraces();
        if (singletonServices.Count == 0)
        {
            builder.AppendLine(@"this.serviceScopeFactory = new ServiceScopeFactory(services, null);");
        }
        else
        {
            builder.AppendLine(@"this.singletonScope = new SingletonServices(null);");
            this.PopulateScopeWithInstances(builder, singletonServices, "this.singletonScope", "services");
            builder.AppendLine(@"this.serviceScopeFactory = new ServiceScopeFactory(services, this.singletonScope);");
        }

        builder.AppendLine(@"this.implicitScope = serviceScopeFactory.CreateScope();");
        builder.CloseBraces();
        builder.AppendLine();

        this.GenerateServiceScopeFactoryClass(builder, scopedServices);
        builder.AppendLine("private ServiceScopeFactory serviceScopeFactory;");
        builder.AppendLine();
        builder.AppendLine(@"private Microsoft.Extensions.DependencyInjection.IServiceScope implicitScope;");
        builder.AppendLine();
        if (singletonServices.Count > 0)
        {
            builder.AppendLine(@"private SingletonServices singletonScope;");
            builder.AppendLine();
        }

        builder.AppendLine(@"public void Dispose()");
        builder.OpenBraces();
        builder.AppendLine(@"implicitScope.Dispose();");
        builder.CloseBraces();
        builder.AppendLine();

        this.GenerateScopedClass("ScopedServices", builder, scopedServices);
        builder.AppendLine();
        if (singletonServices.Count > 0)
        {
            this.GenerateScopedClass("SingletonServices", builder, singletonServices);
            builder.AppendLine();
        }

        builder.AppendLine(@"public object GetService(Type t)
    {
        if (t == typeof(Microsoft.Extensions.DependencyInjection.IServiceScopeFactory))
        {
            return serviceScopeFactory;
        }

        return implicitScope.ServiceProvider.GetService(t);
    }
}");
        builder.PopIndent();
        builder.AppendLine();

        var staticDetectionServices = descriptors
            .Where(_ => !_.UseFactory && !_.UseInstance)
            .Distinct(new ServiceDescriptorComparer())
            .ToArray();
        if (staticDetectionServices.Length > 0)
        {
            this.GenerateServiceReplacement(builder, staticDetectionServices);
        }

        builder.AppendLine(@"public static class StoreKeeperExtensions
{
    public static ServiceProviderAot BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.DependencyInjection.ServiceProviderOptions options)
    {
        return new ServiceProviderAot(services);
    }
    public static ServiceProviderAot BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        return new ServiceProviderAot(services);
    }
}");
        context.AddSource($"ioc_constructor.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private void GenerateServiceReplacement(IndentedStringBuilder builder, ServiceDescriptor[] staticDetectionServices)
    {
        builder.AppendLine(@"internal static class ServicesReplacementExtensions");
        builder.OpenBraces();
        for (var i = 0; i < staticDetectionServices.Length; i++)
        {
            var descriptor = staticDetectionServices[i];
            this.GenerateStaticFactoryMethod(builder, descriptor);
            builder.AppendLine();
        }

        builder.AppendLine(@"public static Microsoft.Extensions.DependencyInjection.IServiceCollection UseAotServices(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        builder.OpenBraces();

        builder.AppendLine("if (services.IsReadOnly)");
        builder.OpenBraces();
        builder.AppendLine(@"throw new System.InvalidOperationException(""Cannot apply AOT improvements on read-only services."");");
        builder.CloseBraces();
        builder.AppendLine();

        builder.AppendLine("for (var i = 0; i < services.Count; i++)");
        builder.OpenBraces();
        builder.AppendLine(@"var descriptor = services[i];");
        for (var i = 0; i < staticDetectionServices.Length; i++)
        {
            var descriptor = staticDetectionServices[i];
            var name = this.GetStaticReplacementFactoryMethod(builder, descriptor);
            builder.AppendLine($@"if (descriptor.ServiceType == typeof({descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}) && descriptor.ImplementationType == typeof({descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}))");
            builder.OpenBraces();
            builder.AppendLine($@"services[i] = new ServiceDescriptor(descriptor.ServiceType, ServicesReplacementExtensions.{name}, descriptor.Lifetime);");
            builder.CloseBraces();
        }

        builder.CloseBraces();
        builder.AppendLine();

        builder.AppendLine("return services;");
        builder.CloseBraces(); // UseAotServices

        builder.CloseBraces();
        builder.AppendLine();
    }

    private string GetStaticReplacementFactoryMethod(IndentedStringBuilder builder, ServiceDescriptor descriptor)
    {
        string name;
        var interfaceType = descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("::", "_")
            .Replace(".", "_");
        if (descriptor.InterfaceType == descriptor.ImplementationType)
        {
            name = $"Build_{interfaceType}";
        }
        else
        {
            var implementationType = descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("::", "_")
                .Replace(".", "_");
            name = $"Build_{interfaceType}_{implementationType}";
        }

        return name;
    }

    private void GenerateStaticFactoryMethod(IndentedStringBuilder builder, ServiceDescriptor descriptor)
    {
        var name = this.GetStaticReplacementFactoryMethod(builder, descriptor);

        builder.AppendLine($"public static object {name}(IServiceProvider serviceProvider)");
        builder.OpenBraces();
        var firstPublicConstructor = this.GetDependencyInjectionConstructor(descriptor);
        for (var i = 0; i < firstPublicConstructor.Parameters.Length; i++)
        {
            var parameter = firstPublicConstructor.Parameters[i];
            var parameterTypeName = parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            builder.AppendLine($"var param_{i} = ({parameterTypeName})serviceProvider.GetService(typeof({parameterTypeName}));");
        }

        IEnumerable<string> parameterStrings = firstPublicConstructor.Parameters.Select((_, index) =>
        {
            string parameterTypeName = _.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"param_{index}";
        });
        var parametersListExpression = string.Join(", ", parameterStrings);
        builder.AppendLine($"return new {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}({parametersListExpression});");
        builder.CloseBraces();
    }

    private void GenerateServiceScopeFactoryClass(IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors)
    {
        builder.AppendLine("private sealed class ServiceScopeFactory : IServiceScopeFactory");
        builder.OpenBraces();
        builder.AppendLine("private Microsoft.Extensions.DependencyInjection.IServiceCollection services;");
        builder.AppendLine();
        builder.AppendLine("private IServiceProvider singletonScope;");
        builder.AppendLine();
        builder.AppendLine("public ServiceScopeFactory(Microsoft.Extensions.DependencyInjection.IServiceCollection services, IServiceProvider singletonScope)");
        builder.OpenBraces();
        builder.AppendLine("this.services = services;");
        builder.AppendLine("this.singletonScope = singletonScope;");
        builder.CloseBraces();
        builder.AppendLine();
        builder.AppendLine("public IServiceScope CreateScope()");
        builder.OpenBraces();
        builder.AppendLine("var result = new ScopedServices(this.singletonScope);");
        this.PopulateScopeWithInstances(builder, descriptors, "result", "this.services");
        builder.AppendLine("return result;");
        builder.CloseBraces();
        builder.CloseBraces();
        builder.AppendLine();
    }

    private void PopulateScopeWithInstances(IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors, string scopeTarget, string servicesVariable)
    {
        if (descriptors.Any(_ => _.UseInstance || _.UseFactory))
        {
            builder.AppendLine($"foreach (var serviceDescriptor in {servicesVariable})");
            builder.OpenBraces();
            foreach (var descriptor in descriptors)
            {
                if (!descriptor.UseInstance && !descriptor.UseFactory)
                {
                    continue;
                }

                var type = descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var backingField = this.GetServiceBackingField(descriptor);
                builder.AppendLine($"if (serviceDescriptor.ServiceType == typeof({type}))");
                builder.OpenBraces();
                if (descriptor.UseInstance)
                {
                    builder.AppendLine($"{scopeTarget}.{backingField} = ({type})serviceDescriptor.ImplementationInstance;");
                }

                if (descriptor.UseFactory)
                {
                    builder.AppendLine($"{scopeTarget}.{backingField}Factory = (Func<IServiceProvider, Object>)serviceDescriptor.ImplementationFactory;");
                }

                builder.CloseBraces();
            }

            builder.CloseBraces();
            builder.AppendLine();
        }
    }

    private void GenerateScopedClass(string className, IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors)
    {
        builder.AppendLine($"internal class {className} : IServiceProvider, Microsoft.Extensions.DependencyInjection.IServiceScope");
        builder.OpenBraces();
        builder.AppendLine("private IServiceProvider singletonScope;");
        builder.AppendLine();
        builder.AppendLine($"public {className}(IServiceProvider singletonScope)");
        builder.OpenBraces();
        builder.AppendLine("this.singletonScope = singletonScope;");
        builder.CloseBraces();
        builder.AppendLine();
        builder.AppendLine("public IServiceProvider ServiceProvider => this;");
        builder.AppendLine();
        builder.AppendLine("public void Dispose()");
        builder.OpenBraces();
        foreach (var descriptor in descriptors.Where(_ => _.IsDisposable))
        {
            var backingField = this.GetServiceBackingField(descriptor);
            builder.AppendLine($"if ({backingField} != null)");
            builder.OpenBraces();
            builder.AppendLine($"((System.IDisposable){backingField}).Dispose();");
            builder.AppendLine($"{backingField} = null;");
            builder.CloseBraces();
            builder.AppendLine();
        }

        builder.CloseBraces();
        builder.AppendLine();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"internal {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {this.GetServiceBackingField(descriptor)};");
            builder.AppendLine();
            if (descriptor.UseFactory)
            {
                builder.AppendLine($"internal Func<IServiceProvider, Object> {this.GetServiceBackingField(descriptor)}Factory;");
                builder.AppendLine();
            }
        }

        builder.AppendLine("public object GetService(Type t)");
        builder.OpenBraces();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"if (t == typeof({descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}))");
            builder.OpenBraces();
            var backingField = this.GetServiceBackingField(descriptor);
            if (descriptor.UseFactory)
            {
                builder.AppendLine($"{backingField} = {backingField} ?? ({descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}){backingField}Factory(this);");
            }
            else if (!descriptor.UseInstance)
            {
                builder.AppendLine($"{backingField} = {backingField} ?? {this.GetInstantiationExpression(descriptor, descriptors)};");
            }

            builder.AppendLine($"return {backingField};");
            builder.CloseBraces();
            builder.AppendLine();
        }

        builder.AppendLine(@"return singletonScope?.GetService(t);");
        builder.CloseBraces();
        builder.CloseBraces();
    }

    private IMethodSymbol GetDependencyInjectionConstructor(ServiceDescriptor descriptor)
    {
        var namedTypeSymbol = descriptor.ImplementationType as INamedTypeSymbol;
        if (namedTypeSymbol is null)
        {
            throw new InvalidOperationException("Cannot resolve type");
        }

        var firstPublicConstructor = namedTypeSymbol.InstanceConstructors.First(_ => _.DeclaredAccessibility == Accessibility.Public);
        return firstPublicConstructor;
    }

    private string GetInstantiationExpression(ServiceDescriptor descriptor, IList<ServiceDescriptor> descriptors)
    {
        var firstPublicConstructor = this.GetDependencyInjectionConstructor(descriptor);
        IEnumerable<string> parameterStrings = firstPublicConstructor.Parameters.Select(_ =>
        {
            string parameterTypeName = _.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"({parameterTypeName})GetService(typeof({parameterTypeName}))";
        });
        var parametersListExpression = string.Join(", ", parameterStrings);
        return $"new {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}({parametersListExpression})";
    }

    private string GetServiceBackingField(ServiceDescriptor descriptor)
    {
        return $"_{descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace('.', '_')}";
    }

    internal class ServiceDescriptorComparer : IEqualityComparer<ServiceDescriptor>
    {
        public bool Equals(ServiceDescriptor x, ServiceDescriptor y)
        {
            return x.ImplementationType == y.ImplementationType
                && x.InterfaceType == y.InterfaceType;
        }

        public int GetHashCode(ServiceDescriptor obj)
        {
            return obj.InterfaceType.GetHashCode() ^ obj.ImplementationType.GetHashCode();
        }
    }

    internal class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<ServiceDescriptor> DetectedServices { get; } = new();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is InvocationExpressionSyntax invocationExpressionSyntax)
            {
                if (invocationExpressionSyntax.Expression is not MemberAccessExpressionSyntax memberAccessException)
                {
                    return;
                }

                var name = memberAccessException.Name;
                var x = name.ToString();
                if (x.StartsWith("AddScoped") || x.StartsWith("AddSingleton") || x.StartsWith("AddTransient"))
                {
                    if (name is GenericNameSyntax genericNameSyntax)
                    {
                        this.ProcessGenericSyntax(context, genericNameSyntax);
                    }
                    else if (name is IdentifierNameSyntax identifierNameSyntax)
                    {
                        var argument = invocationExpressionSyntax.ArgumentList.Arguments[0];
                        if (argument.Expression is TypeOfExpressionSyntax)
                        {
                            return;
                        }

                        TypeInfo interfaceTypeInfo = GetExpressionType(context, argument);
                        if (interfaceTypeInfo.Type is not null)
                        {
                            var useInstance = argument.Expression is ObjectCreationExpressionSyntax;
                            var scope = (ServiceScope)Enum.Parse(typeof(ServiceScope), x.Substring(3));
                            var descriptor = new ServiceDescriptor(
                                scope,
                                interfaceTypeInfo.Type,
                                interfaceTypeInfo.Type)
                            {
                                UseInstance = useInstance,
                                UseFactory = !useInstance,
                            };
                            this.DetectedServices.Add(descriptor);
                        }
                    }
                }
            }
        }

        private static TypeInfo GetExpressionType(GeneratorSyntaxContext context, ArgumentSyntax argument)
        {
            var expression = argument.Expression switch
            {
                ParenthesizedLambdaExpressionSyntax pes => pes.ExpressionBody ?? throw new NotSupportedException("Complex lambda expression does not supported"),
                _ => argument.Expression,
            };
            return context.SemanticModel.GetTypeInfo(expression);
        }

        private void ProcessGenericSyntax(GeneratorSyntaxContext context, GenericNameSyntax genericNameSyntax)
        {
            var identifier = genericNameSyntax.Identifier;
            if (!Enum.TryParse<ServiceScope>(identifier.ToString().Substring(3), out var scope))
            {
                return;
            }

            var typesList = genericNameSyntax.TypeArgumentList.Arguments;
            var interfaceType = typesList[0];
            var implementationType = typesList.ElementAtOrDefault(1) ?? interfaceType;
            TypeInfo interfaceTypeInfo = context.SemanticModel.GetTypeInfo(interfaceType);
            TypeInfo implementationTypeInfo = context.SemanticModel.GetTypeInfo(implementationType);
            if (interfaceTypeInfo.Type is not null && implementationTypeInfo.Type is not null)
            {
                ServiceDescriptor descriptor = new ServiceDescriptor(
                    scope,
                    interfaceTypeInfo.Type,
                    implementationTypeInfo.Type);
                this.DetectedServices.Add(descriptor);
            }
        }
    }
}
