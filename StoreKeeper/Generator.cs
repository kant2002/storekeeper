// -----------------------------------------------------------------------
// <copyright file="Generator.cs" company="Andrii Kurdiumov">
// Copyright (c) Andrii Kurdiumov. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace StoreKeeper;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <summary>
/// Generator for IOC storage.
/// </summary>
[Generator]
public partial class Generator : ISourceGenerator
{
    /// <summary>
    /// Gets or sets a value indicating whether generate file headers.
    /// </summary>
    public bool GenerateHeaders { get; set; } = true;

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        // context.RegisterForPostInitialization((pi) => pi.AddSource("SqlMarshalAttribute.cs", AttributeSource));
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        var hasNullableAnnotations = context.Compilation.Options.NullableContextOptions != NullableContextOptions.Disable;

        const string AutoGeneratedHeader = @"// <auto-generated>
// Code generated by Store Keeper Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#pragma warning disable 1591
";

        var sourceCode = new IndentedStringBuilder(this.GenerateHeaders ? AutoGeneratedHeader : string.Empty);
        sourceCode.AppendLine("using System;");
        sourceCode.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceCode.AppendLine();
        sourceCode.AppendLine(@"public sealed class ServiceProviderAot : IServiceProvider, System.IDisposable");
        sourceCode.OpenBraces();
        this.GenerateServiceScopeFactoryClass(sourceCode);
        sourceCode.AppendLine(@"private ScopedServices implicitScope = new ScopedServices();");
        sourceCode.AppendLine();

        sourceCode.AppendLine(@"public void Dispose()");
        sourceCode.OpenBraces();
        sourceCode.AppendLine(@"implicitScope.Dispose();");
        sourceCode.CloseBraces();
        sourceCode.AppendLine();

        var descriptors = receiver.DetectedServices;
        this.GenerateScopedClass(sourceCode, descriptors);
        sourceCode.AppendLine();
        sourceCode.AppendLine(@"public object GetService(Type t)
    {
        if (t == typeof(Microsoft.Extensions.DependencyInjection.IServiceScopeFactory))
        {
            return serviceScopeFactory;
        }

        return implicitScope.GetService(t);
    }
}

public static class StoreKeeperExtensions
{
    public static ServiceProviderAot BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services, Microsoft.Extensions.DependencyInjection.ServiceProviderOptions options)
    {
        return new ServiceProviderAot();
    }
    public static ServiceProviderAot BuildServiceProviderAot(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        return new ServiceProviderAot();
    }
}");
        context.AddSource($"ioc_constructor.cs", SourceText.From(sourceCode.ToString(), Encoding.UTF8));
    }

    private void GenerateServiceScopeFactoryClass(IndentedStringBuilder builder)
    {
        builder.AppendLine("private sealed class ServiceScopeFactory : IServiceScopeFactory");
        builder.OpenBraces();
        builder.AppendLine("public IServiceScope CreateScope()");
        builder.OpenBraces();
        builder.AppendLine("return new ScopedServices();");
        builder.CloseBraces();
        builder.CloseBraces();
        builder.AppendLine();
        builder.AppendLine("private ServiceScopeFactory serviceScopeFactory = new ServiceScopeFactory();");
        builder.AppendLine();
    }

    private void GenerateScopedClass(IndentedStringBuilder builder, IList<ServiceDescriptor> descriptors)
    {
        builder.AppendLine("internal class ScopedServices : IServiceProvider, IServiceScope");
        builder.AppendLine("{");
        builder.PushIndent();
        builder.AppendLine("public IServiceProvider ServiceProvider => this;");
        builder.AppendLine();
        builder.AppendLine("public void Dispose()");
        builder.AppendLine("{");
        builder.PushIndent();
        foreach (var descriptor in descriptors.Where(_ => _.IsDisposable))
        {
            var backingField = this.GetServiceBackingField(descriptor);
            builder.AppendLine($"if ({backingField} != null)");
            builder.AppendLine("{");
            builder.PushIndent();
            builder.AppendLine($"((System.IDisposable){backingField}).Dispose();");
            builder.AppendLine($"{backingField} = null;");
            builder.PopIndent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.PopIndent();
        builder.AppendLine("}");
        builder.AppendLine();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"private {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {this.GetServiceBackingField(descriptor)};");
            builder.AppendLine();
        }

        builder.AppendLine("public object GetService(Type t)");
        builder.AppendLine("{");
        builder.PushIndent();
        foreach (var descriptor in descriptors)
        {
            builder.AppendLine($"if (t == typeof({descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}))");
            builder.AppendLine("{");
            builder.PushIndent();
            var backingField = this.GetServiceBackingField(descriptor);
            builder.AppendLine($"{backingField} = {backingField} ?? {this.GetInstantiationExpression(descriptor, descriptors)};");
            builder.AppendLine($"return {backingField};");
            builder.PopIndent();
            builder.AppendLine("}");
            builder.AppendLine();
        }

        builder.AppendLine(@"return null;");
        builder.PopIndent();

        builder.AppendLine("}");
        builder.PopIndent();
        builder.AppendLine("}");
    }

    private string GetInstantiationExpression(ServiceDescriptor descriptor, IList<ServiceDescriptor> descriptors)
    {
        return $"new {descriptor.ImplementationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}()";
    }

    private string GetServiceBackingField(ServiceDescriptor descriptor)
    {
        return $"_{descriptor.InterfaceType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace('.', '_')}";
    }

    internal class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<ServiceDescriptor> DetectedServices { get; } = new();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is MemberAccessExpressionSyntax invocationExpressionSyntax)
            {
                var x = invocationExpressionSyntax.Name.ToString();
                if (x.StartsWith("AddScoped") || x.StartsWith("AddSingleton") || x.StartsWith("AddTransient"))
                {
                    var name = invocationExpressionSyntax.Name;
                    if (name is GenericNameSyntax genericNameSyntax)
                    {
                        var identifier = genericNameSyntax.Identifier;
                        var typesList = genericNameSyntax.TypeArgumentList.Arguments;
                        var interfaceType = typesList[0];
                        var implementationType = typesList.ElementAtOrDefault(1) ?? interfaceType;
                        if (Enum.TryParse<ServiceScope>(identifier.ToString().Substring(3), out var scope))
                        {
                            TypeInfo interfaceTypeInfo = context.SemanticModel.GetTypeInfo(interfaceType);
                            TypeInfo implementationTypeInfo = context.SemanticModel.GetTypeInfo(implementationType);
                            if (interfaceTypeInfo.Type is not null && implementationTypeInfo.Type is not null)
                            {
                                ServiceDescriptor descriptor = new ServiceDescriptor(
                                    scope,
                                    interfaceTypeInfo.Type,
                                    implementationTypeInfo.Type);
                                this.DetectedServices.Add(descriptor);
                            }
                        }
                    }
                }
            }
        }
    }
}
